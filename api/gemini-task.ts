
import type { VercelRequest, VercelResponse } from '@vercel/node';
import { GoogleGenAI } from '@google/genai';

// üé® –¶–≤–µ—Ç–∞ –¥–ª—è –∫–æ–Ω—Å–æ–ª–∏
const colors = {
  reset: "\x1b[0m", gray: "\x1b[90m", red: "\x1b[31m", 
  green: "\x1b[32m", yellow: "\x1b[33m", blue: "\x1b[34m",
  magenta: "\x1b[35m", cyan: "\x1b[36m", bold: "\x1b[1m"
};

// --- –ü–æ–ª—É—á–µ–Ω–∏–µ –∏ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ –∫–ª—é—á–µ–π API (–∏–∑ gemini-proxy) ---
const getApiKeys = (): string[] => {
  const keys: string[] = [];
  if (process.env.API_KEY) keys.push(process.env.API_KEY);
  let i = 2;
  while (process.env[`API_KEY_${i}`]) {
    keys.push(process.env[`API_KEY_${i}`]!);
    i++;
  }
  return keys;
};

const shuffleArray = <T>(array: T[]): T[] => {
  const arr = [...array];
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};

// --- Stateless Task Encoding/Decoding ---
// We encode the prompt into the taskId itself to avoid state on the server.
const encodeTask = (prompt: string): string => {
    // Using base64url is safer for query parameters than standard base64.
    return Buffer.from(prompt).toString('base64url');
};

const decodeTask = (taskId: string): string => {
    return Buffer.from(taskId, 'base64url').toString('utf-8');
};


// --- –û—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ API ---
export default async function handler(req: VercelRequest, res: VercelResponse) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') return res.status(204).end();

  // POST: –°–æ–∑–¥–∞—Ç—å stateless ID –∑–∞–¥–∞—á–∏
  if (req.method === 'POST') {
    const { prompt } = req.body;
    if (!prompt || typeof prompt !== 'string') {
        return res.status(400).json({ error: '–í —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ø–æ–ª–µ "prompt"' });
    }
    const taskId = encodeTask(prompt);
    console.log(`${colors.cyan}‚ú® –°–æ–∑–¥–∞–Ω stateless ID –∑–∞–¥–∞—á–∏...${colors.reset}`);
    return res.status(200).json({ taskId });
  }

  // GET: –í—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞—á—É –∏ —Å—Ç—Ä–∏–º–∏—Ç—å –æ—Ç–≤–µ—Ç
  if (req.method === 'GET') {
    const { taskId } = req.query;
    if (!taskId || typeof taskId !== 'string') {
        return res.status(400).json({ error: '–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä "taskId"' });
    }
    
    let contents: string;
    try {
        contents = decodeTask(taskId);
    } catch (error) {
        return res.status(400).json({ error: '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID –∑–∞–¥–∞—á–∏' });
    }

    const apiKeys = shuffleArray(getApiKeys());
    if (apiKeys.length === 0) {
        return res.status(500).json({ error: '–ö–ª—é—á–∏ API –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ' });
    }

    console.log(`${colors.cyan}${colors.bold}üß† –ù–∞—á–∏–Ω–∞—é —Å—Ç—Ä–∏–º –¥–ª—è –∑–∞–¥–∞—á–∏...${colors.reset}`);
    const startTime = Date.now();
    let lastError: any = null;
    let handled = false;

    for (const apiKey of apiKeys) {
        const shortKey = apiKey.slice(-6);
        try {
            const ai = new GoogleGenAI({ apiKey });
            const streamResponse = await ai.models.generateContentStream({
                model: 'gemini-2.5-flash',
                contents,
            });

            res.setHeader('Content-Type', 'text/plain; charset=utf-8');
            res.setHeader('Cache-Control', 'no-cache');
            res.setHeader('Connection', 'keep-alive');
            res.status(200);

            for await (const chunk of streamResponse) {
                const text = chunk.text;
                if (text) {
                    res.write(text);
                }
            }
            
            res.end();
            const duration = Date.now() - startTime;
            console.log(`${colors.green}‚úÖ –ö–ª—é—á ...${shortKey}${colors.reset} —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–∏–ª —Å—Ç—Ä–∏–º –∑–∞ ${duration} –º—Å`);
            handled = true;
            break;

        } catch (err: any) {
            lastError = err;
            const msg = (err.message || '').toLowerCase();
            if (msg.includes('429') || msg.includes('quota') || msg.includes('too many requests')) {
                console.warn(`${colors.yellow}‚õî –ö–ª—é—á ...${shortKey} –∏—Å—á–µ—Ä–ø–∞–ª –ª–∏–º–∏—Ç. –ü–µ—Ä–µ–∫–ª—é—á–∞—é—Å—å...${colors.reset}`);
                continue;
            }
            console.error(`${colors.red}‚ùå –ù–µ–ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º–∞—è –æ—à–∏–±–∫–∞ (–∫–ª—é—á ...${shortKey}):${colors.reset} ${err.message}`);
            break;
        }
    }

    if (!handled && !res.headersSent) {
        console.error(`${colors.red}${colors.bold}üí• –í—Å–µ –∫–ª—é—á–∏ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏. –ü–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞:${colors.reset}`, lastError?.message);
        res.status(500).json({
            error: '–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å –∫ Gemini API',
            details: lastError?.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞.',
        });
    }
    return;
  }

  return res.status(405).json({ error: '–ú–µ—Ç–æ–¥ –Ω–µ —Ä–∞–∑—Ä–µ—à–µ–Ω' });
}
